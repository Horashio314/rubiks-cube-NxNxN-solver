
- build the 4900 tables for 6x6x6 LFRB centers

- tsai...need something better


- 6x6x6 LR edge pairing build 70 tables and merge them
    - This is after they have already been staged and we are pairing them up.  When we
      pair them up we are forcing them to their final position but that isn't needed.

    - Do the same for FB prune table



- B-Trees...this will benefit all searches
    - when this is done delete LookupTableIDA666UDObliqueEdgePairing and keep LookupTableIDA666CpuMaxUDObliqueEdgePairing
    - when this is done delete LookupTableIDA555CpuMinUDCentersStage and keep LookupTableIDA555UDCentersStage
    - that will eliminate all of the "fake move" crazyness


- TPR solver
    - how the hell does it work so fast?
    - ideas
        - before we start IDA we could see which EO edge mapping gives us the
          shortest edge heuristic and stick with that one.  We would need to go
          back to the 0 line dummy table and
          LookupTableIDA444TsaiPhase2.experimental_ida_search_complete()

          Or we could build out a small lookup table (say 3 moves deep) for that
          one edge mapping.

- xyzzy's 5x5x5 solver. It is a variation of the TPR solver so need to understand TPR first.
    - he does an EO (edge orientation) step.  If all larger solvers that use 5x5x5 for edge
      pairing could also do EO then maybe we could toss the edge pairing code...there is a
      ton of it and it is hideous.

- bidir IDA search
    - I need to understand how the TPR solver works before I spend time on bidir IDA
    - would allow us to find slighly shorter solutions than we do today
    - may potentially allow us tackle much larger IDA searches...TBD
        - first to try is staging all 5x5x5 centers via one phase
        - second to try is staging all 5x5x5 centers via one phase
        - combine phases 1 and 2 of tsai?
    - start from a solved cube and work your way back to the scrambled cube
    - requires us to build prune tables for each scrambled cube
        - for 4x4x4 staging centers we can do this in XYZ minutes in python
        - if we only build it out 4 steps deep we can do it in ~20s
        - so this would have to be done in C and even then it would still
          take some time.  I think this is a strategy that could only be
          used in a fewest moves challenge given how long it will take to
          produce solutions.



B-Tree notes
============
- optimaly load the B-Trees
- support for loading the first two levels in memory and finding the rest on disk

- Once the two bullets above are done we should be able to find a key via
  a single seek(). We should also be able to only do one rstrip/split(',')
  call, it should only happen when 'if key in key_line' is True.

  Today we take ~14s where our time is in:

   974730    0.533    0.000    0.533    0.000 {method 'seek' of '_io.BufferedReader' objects}
  1431684    0.721    0.000    0.721    0.000 {method 'decode' of 'bytes' objects}
 127280/3    0.733    0.000   17.547    5.849 LookupTable.py:675(ida_search)
   779505    0.920    0.000    0.920    0.000 {method 'read' of '_io.BufferedReader' objects}
  1307535    1.435    0.000    1.435    0.000 {method 'rstrip' of 'str' objects}
   915393    1.451    0.000    1.451    0.000 {built-in method builtins.next}
  1372371    2.557    0.000    2.557    0.000 {method 'split' of 'str' objects}
   195231    3.299    0.000   11.243    0.000 __init__.py:67(disk_get)
   ncalls  tottime  percall  cumtime  percall filename:lineno(function)

    So we should end up with
    - seek()   : should come down to 195231...should shave about 300ms

    - decode() : Will 'if key in key_line' work if it is not decoded to utf-8?
        If so we can avoid all of these calls....should shave 721ms.

    - read()   : should come down to 195231...should shave about 600ms

    - rstrip() : can only call this 'if key in key_line' which should chop 99% of them..should shave 1435ms

    - next() : is called today to load the nodes line...we can avoid this if we know that we are already at the leaf node depth
        This should shave 1451ms

    - split() : can only call this 'if key in key_line' which should chop 99% of them..should shave 2557ms

    That is about ~7000ms we can shave...would get us from 14s down to 7s which would be awesome


- Test this against slow 6x6x6 UD oblique:

./usr/bin/rubiks-cube-solver.py --cpu-max --state FBDDDFFUDRFBBLFLLURLDLLUFBLRFDUFLBLLFBFLRRBBFDRRDUBUFRBUBRDLUBFDRLBBRLRUFLBRBDUDFFFDBLUDBBLRDFUUDLBBBRRDRUDLBLDFRUDLLFFUUBFBUUFDLRUDUDBRRBBUFFDRRRDBULRRURULFDBRRULDDRUUULBLLFDFRRFDURFFLDUUBRUFDRFUBLDFULFBFDDUDLBLLRBL


2017-12-17 09:52:42,776 RubiksCube666.py     INFO: UD inner x-centers staged, 5 steps in
2017-12-17 09:52:42,777   LookupTable.py     INFO: 6x6x6-step25-UD-oblique-edge-pairing: IDA threshold range 7->99
2017-12-17 09:52:43,134   LookupTable.py     INFO: 6x6x6-step25-UD-oblique-edge-pairing: IDA threshold 7, explored 2882 branches, took 356ms
2017-12-17 09:52:52,335   LookupTable.py     INFO: 6x6x6-step25-UD-oblique-edge-pairing: IDA threshold 8, explored 86762 branches, took 0:00:09.201718
2017-12-17 09:52:55,953   LookupTable.py     INFO: 6x6x6-step25-UD-oblique-edge-pairing: IDA found match 6 steps in, f_cost 10 (6 + 4)
2017-12-17 09:52:55,953   LookupTable.py     INFO: 6x6x6-step25-UD-oblique-edge-pairing: IDA threshold 9, explored 37636 branches, took 0:00:03.617328 (0:00:13.176431 total)

This search takes about 5 million seek() calls when using binary search...the seeks are the top bottleneck thus the need to move to B-Trees



misc notes
==========
- ida_search() needs to return all of the results at that theshold
Test on this one, 5x5x5-step20-LR-centers-stage  finds a solution 12 steps long but I know there is one
that is 10 steps long (I found it via AStar)

./usr/bin/rubiks-cube-solver.py --state RFFFUDUDURBFULULFDBLRLDUFDBLUBBBDDURLRDRFRUDDBFUFLFURRLDFRRRUBFUUDUFLLBLBBULDDRRUFUUUBUDFFDRFLRBBLRFDLLUUBBRFRFRLLBFRLBRRFRBDLLDDFBLRDLFBBBLBLBDUUFDDD

I have a partial patch for this (patches/ida_solutions_use_best.patch) but it needs some work.
We need to pseudo combine multiple phases to get shorter solutions. For example
we need to find multiple solutions for staging UD centers and then for each of those find multiple
solutions for staging LR centers and keep the one that allows us to solve the 5x5x5 centers in the
least number of steps. That is a lot of IDA searches though so this all has to happen after
the bplustree work is done.

